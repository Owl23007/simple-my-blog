---
title: 第二章 软件设计原则
date: 2025-11-19
description: 详细介绍SOLID原则及其他软件设计原则，包括SRP、OCP、LSP、ISP、DIP等。
prev:
  text: '第一章 软件设计基础'
  link: '/series/软件设计体系结构/01-软件设计基础'
next:
  text: '第三章 UML 基础与建模实践'
  link: '/series/软件设计体系结构/03-UML基础与建模实践'
---
# 第二章 软件设计原则

设计原则是创建高质量软件的基础。遵循这些原则，能让代码更易维护、扩展和测试。本章重点介绍SOLID原则及其他核心原则。

## 1 SOLID原则概述

solid 中文意思是固体，SOLID是面向对象设计的五个核心原则的缩写：

| 原则 | 英文缩写 | 核心思想 |
|------|----------|----------|
| **单一职责原则** | SRP | 一个类只负责一个功能 |
| **开闭原则** | OCP | 对扩展开放，对修改关闭 |
| **里氏替换原则** | LSP | 子类可替换父类而不破坏程序 |
| **接口隔离原则** | ISP | 客户端不应依赖不需要的接口 |
| **依赖倒置原则** | DIP | 依赖抽象，而非具体实现 |

### 单一职责原则（SRP）

**一个类应该只有一个改变的理由。**

```java
// 违反 SRP：一个类处理多种职责
class UserManager {
    public void createUser(User user) { /* 创建用户 */ }
    public void sendEmail(User user) { /* 发送邮件 */ }
    public void logActivity(String activity) { /* 记录日志 */ }
}

// 遵循 SRP：职责分离
class UserService {
    public void createUser(User user) { /* 创建用户 */ }
}

class EmailService {
    public void sendEmail(User user) { /* 发送邮件 */ }
}

class Logger {
    public void logActivity(String activity) { /* 记录日志 */ }
}
```

:::tip 小结

- 单一职责原则：一个类只负责一个功能，避免类过度复杂

单一职责原则直观地体现就是将实现特定功能的类只负责这一功能，而不负责其他功能。

实际上，这不仅是为了方便理解与管理，更是方便了代码的复用。

比如将自定义实现的 base62方法封装成一个 base62类，程序全局使用同一个 base62 算法，既能保证全局统一，又方便了复用。

:::

### 开闭原则（OCP）

**软件实体对扩展开放，对修改关闭。**

```java
// 违反 OCP：添加新形状需修改代码
class ShapeDrawer {
    public void drawShape(String shapeType) {
        if (shapeType.equals("circle")) { /* 绘制圆 */ }
        else if (shapeType.equals("square")) { /* 绘制方 */ }
    }
}

// 遵循 OCP：通过接口扩展
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() { /* 绘制圆 */ }
}

class Square implements Shape {
    public void draw() { /* 绘制方 */ }
}

class ShapeDrawer {
    public void drawShape(Shape shape) {
        shape.draw();
    }
}
```

:::tip 小结

- 开闭原则：通过扩展，而不是修改代码

开闭原则是指软件实体（类、模块、函数等）对扩展开放，对修改关闭。

实际开发中，我们不仅要写新的功能，还需对以写功能进行测试。满足开闭原则，在添加新的代码时，只需要验证新的代码是否正确，而不需要验证原有的代码。

>[!WARNING]注意：
>
>- "对修改关闭"不是绝对禁止修改，而是指核心逻辑不应因功能扩展而频繁变更。
>- 良好的抽象是前提。若一开始没设计好接口，后期仍可能被迫重构。
:::

### 里氏替换原则（LSP）

**子类对象能够替换其父类对象，而不破坏程序正确性。**

```java
// ❌ 违反 LSP：鸵鸟不能飞，替换Bird会出错
class Bird {
    public void fly() { /* 飞行 */ }
}

class Ostrich extends Bird {
    public void fly() {
        throw new UnsupportedOperationException("鸵鸟不会飞");
    }
}

// ✅ 遵循 LSP：抽象行为，确保子类正确实现
abstract class Bird {
    public abstract void move();
}

class Sparrow extends Bird {
    public void move() { /* 飞行 */ }
}

class Ostrich extends Bird {
    public void move() { /* 行走 */ }
}
```

### 接口隔离原则（ISP）

**客户端不应被迫依赖其不使用的接口。**

```java
// ❌ 违反 ISP：机器人被迫实现不需要的方法
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() { /* 工作 */ }
    public void eat() { /* 机器人不需要吃 */ }
}

// ✅ 遵循 ISP：拆分接口，按需实现
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Human implements Workable, Eatable {
    public void work() { /* 工作 */ }
    public void eat() { /* 吃饭 */ }
}

class Robot implements Workable {
    public void work() { /* 工作 */ }
}
```

### 依赖倒置原则（DIP）

**高层模块不应依赖低层模块，两者都应依赖抽象。**

```java
// ❌ 违反 DIP：高层直接依赖低层
class LightBulb {
    public void turnOn() { /* 开灯 */ }
}

class Switch {
    private LightBulb bulb;
    public Switch(LightBulb bulb) {
        this.bulb = bulb;
    }
    public void operate() {
        bulb.turnOn();
    }
}

// ✅ 遵循 DIP：依赖抽象接口
interface Switchable {
    void turnOn();
}

class LightBulb implements Switchable {
    public void turnOn() { /* 开灯 */ }
}

class Switch {
    private Switchable device;
    public Switch(Switchable device) {
        this.device = device;
    }
    public void operate() {
        device.turnOn();
    }
}
```

## 2 其他重要设计原则

### 迪米特法则（最少知识原则）

**一个对象应该只与其直接朋友交互。**

```java
// ❌ 违反法则：直接访问陌生对象
class Client {
    public void process(A a) {
        C c = a.getB().getC(); // 访问链过长
        c.doSomething();
    }
}

// ✅ 遵循法则：只与直接朋友交互
class Client {
    public void process(A a) {
        a.process(); // 封装内部交互
    }
}
```

### 高内聚低耦合

- **高内聚**：类内元素紧密相关
- **低耦合**：类间依赖最小化

### 组合优于继承

**优先使用组合，而非继承。**

```java
// 继承：Car继承Vehicle
class Car extends Vehicle { /* ... */ }

// 组合：Car组合Engine，更灵活
class Car {
    private Engine engine;
    public Car(Engine engine) {
        this.engine = engine;
    }
}
```

::: danger 常见误区
- **过度设计**：不是所有代码都要遵循所有原则
- **教条主义**：原则是指导，不是绝对规则
- **忽略上下文**：简单项目无需复杂抽象

> **原则是手段，质量是目标。**
:::
