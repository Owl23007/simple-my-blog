---
title: 第二章 软件设计原则
date: 2025-11-19
description: 详细介绍SOLID原则及其他软件设计原则，包括SRP、OCP、LSP、ISP、DIP等。
outline: [2,3]
prev:
  text: '第一章 软件设计基础'
  link: '/series/软件设计体系结构/01-软件设计基础'
next:
  text: '第三章 UML 基础与建模实践'
  link: '/series/软件设计体系结构/03-UML基础与建模实践'
---
# 第二章 软件设计原则

设计原则是创建高质量软件的基础。遵循这些原则，能让代码更易维护、扩展和测试。本章重点介绍SOLID原则及其他核心原则。

## 1 SOLID原则概述

solid 中文意思是固体，SOLID是面向对象设计的五个核心原则的缩写：

| 原则 | 英文缩写 | 核心思想 |
|------|----------|----------|
| **单一职责原则** | SRP | 一个类只负责一个功能 |
| **开闭原则** | OCP | 对扩展开放，对修改关闭 |
| **里氏替换原则** | LSP | 子类可替换父类而不破坏程序 |
| **接口隔离原则** | ISP | 客户端不应依赖不需要的接口 |
| **依赖倒置原则** | DIP | 依赖抽象，而非具体实现 |

### 单一职责原则（SRP）

单一职责原则（**single** responsibility principle, SRP）核心为：

**一个类应该只有一个改变的理由。**

```java
// 违反 SRP：一个类处理多种职责
class UserManager {
    public void createUser(User user) { /* 创建用户 */ }
    public void sendEmail(User user) { /* 发送邮件 */ }
    public void logActivity(String activity) { /* 记录日志 */ }
}

// 遵循 SRP：职责分离
class UserService {
    public void createUser(User user) { /* 创建用户 */ }
}

class EmailService {
    public void sendEmail(User user) { /* 发送邮件 */ }
}

class Logger {
    public void logActivity(String activity) { /* 记录日志 */ }
}
```

:::tip 小结

- 单一职责原则：一个类只负责一个功能，避免类过度复杂

单一职责原则直观地体现就是将实现特定功能的类只负责这一功能，而不负责其他功能。

实际上，这不仅是为了方便理解与管理，更是方便了代码的复用。

比如将自定义实现的 base62方法封装成一个 base62类，程序全局使用同一个 base62 算法，既能保证全局统一，又方便了复用。

:::

### 开闭原则（OCP）

开闭原则（**open** **closed** principle, OCP）核心为：

**软件实体对扩展开放，对修改关闭。**

```java
// 违反 OCP：添加新形状需修改代码
class ShapeDrawer {
    public void drawShape(String shapeType) {
        if (shapeType.equals("circle")) { /* 绘制圆 */ }
        else if (shapeType.equals("square")) { /* 绘制方 */ }
    }
}

// 遵循 OCP：通过接口扩展
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() { /* 绘制圆 */ }
}

class Square implements Shape {
    public void draw() { /* 绘制方 */ }
}

class ShapeDrawer {
    public void drawShape(Shape shape) {
        shape.draw();
    }
}
```

:::tip 小结

- 开闭原则：通过扩展，而不是修改代码

开闭原则是指软件实体（类、模块、函数等）对扩展开放，对修改关闭。

实际开发中，我们不仅要写新的功能，还需对以写功能进行测试。满足开闭原则，在添加新的代码时，只需要验证新的代码是否正确，而不需要验证原有的代码。

>[!WARNING]注意：
>
>- "对修改关闭"不是绝对禁止修改，而是指核心逻辑不应因功能扩展而频繁变更。
>- 良好的抽象是前提。若一开始没设计好接口，后期仍可能被迫重构。
:::

### 里氏替换原则（LSP）

里氏替换原则（Liskov Substitution Principle, LSP）由 Barbara Liskov 在 1987 年提出。其核心为：

**子类对象能够替换其父类对象，而不破坏程序的正确性。**

#### 举个例子：插座与插头

想象你家里有个插板，都是使用 **标准两脚插头（父类）**，墙上的插座也只接受这种插头。

如果你买了一个使用 **三脚插头（子类）** 的新电器并强行插入两脚插座，可能会：

- 插不进去
- 弄坏插座
- 甚至短路起火

尽管“三脚插头 是 插头”，但它**不能无缝替换两脚插头**——这就是违反 LSP 的直观例子。

#### 回到编程：为什么这很重要

假设存在一个使用者函数：

```java
// 使用者：依赖 Rectangle 的行为约定
public double calculateArea(Rectangle r) {
    r.setWidth(10);
    r.setHeight(5);
    return r.getArea(); // 期望返回 50
}
```

如果传入了 `Square`：

```java
calculateArea(new Square()); // 可能返回 25 而不是 50
```

问题不在 `Square` 是否“错”，而在于 **`Square` 不应当继承自 `Rectangle`（在此行为契约下）**。在“宽与高可独立设置”的契约下，正方形并不总是矩形的子类型。

> 继承不是概念上的包含，而是行为兼容的契约。

#### 违反 LSP 会带的后果

- 调用方基于父类契约编写代码，如果子类改变行为，调用方无法预期
- 被迫增加类型检查（`instanceof`）或特殊分支，破坏多态
- 代码变脆弱、难以维护

这类似插错电压的 USB‑C 充电器，看起来接口一致，但行为不同，会造成严重后果。

#### 正确的继承应满足的契约

子类必须遵守父类的行为约定，主要包括：

| 方面 | 父类约定 | 子类必须做到 |
|------|----------|--------------|
| 前置条件（输入） | 接受任意正整数 | 不能变为只接受偶数 |
| 后置条件（输出） | 返回非负数 | 不能返回负数 |
| 异常 | 不抛异常 | 不能随意抛 RuntimeException |
| 不变性 | 宽×高 = 面积 | 必须保持该不变性 |

子类可以扩展行为（新增方法），但不得破坏已有契约。

#### 继承的契约：子类如何正确替代父类

无论是`List<Integer> list = new LinkedList<>();` 还是 `Deque<Integer> deque = new LinkedList<>();`都满足 **里氏替换原则**：

> **`LinkedList` 作为 `List` 的实现类，能完全替代 `List`；作为 `Deque` 的实现类，也能完全替代 `Deque`。使用者只依赖接口，不关心具体实现。**

核心区别：**接口不同 → 契约不同 → 可用行为不同**

---

##### 1. `List<Integer> list = new LinkedList<>();`

- **接口契约**：`List` 接口定义了“**有序、可重复、按索引访问**”的集合行为。
- **你能调用的方法**（仅限 `List` 声明的方法）：

  ```java
  list.add(1);           // 末尾添加（List 约定）
  list.get(0);           // 按索引获取（O(n) 对 LinkedList 不高效，但语义合法）
  list.set(0, 2);        // 按索引修改
  list.remove(0);        // 按索引删除
  ```

- **关键点**：
  - 你**不能**调用 `offerFirst()`、`pollLast()` 等双端队列方法（编译报错）。
  - 即使底层是 `LinkedList`，你也**只能用 `List` 的视角看待它**。
  - `LinkedList` 保证：所有 `List` 方法的行为符合 `List` 的规范（比如 `add()` 加到末尾，`get(i)` 返回第 i 个元素）

##### 2. `Deque<Integer> deque = new LinkedList<>();`

- **接口契约**：`Deque`（Double-ended Queue）接口定义了“**两端都能插入/删除**”的队列行为。
- **你能调用的方法**（仅限 `Deque` 声明的方法）：

  ```java
  deque.addFirst(1);     // 从头部插入
  deque.addLast(2);      // 从尾部插入（等价于 add()）
  deque.pollFirst();     // 从头部移除并返回
  deque.pollLast();      // 从尾部移除并返回
  deque.peekFirst();     // 查看头部元素
  ```

- **关键点**：
  - 你**不能**调用 `get(0)`、`set(1, x)` 等基于索引的方法（`Deque` 接口没定义这些！）。
  - 即使底层是 `LinkedList`，你也**只能用 `Deque` 的视角看待它**。
  - `LinkedList` 保证：所有 `Deque` 方法的行为符合 `Deque` 的规范（比如 `addFirst()` 确实加到头部）。

> 这里，`LinkedList` 也是 `Deque` 的“行为子类型”——它完全遵守 `Deque` 的契约。

:::tip 为什么同一个 `LinkedList` 能同时满足两个不同的契约？

因为 **`LinkedList` 类在设计时，同时实现了 `List` 和 `Deque` 接口**：

```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
```

- 它为 `List` 接口提供了一套符合“有序列表”语义的实现；
- 它为 `Deque` 接口提供了一套符合“双端队列”语义的实现；

对应的要写出两套方法实现，分别遵守各自的契约，但 **两套实现互不干扰，各自遵守各自的契约**。
:::

#### 一句话总结

> 里氏替换原则的本质是：继承必须保证行为可预测性。若替换导致错误，说明设计（继承关系）有问题。

### 接口隔离原则（ISP）

**客户端不应被迫依赖其不使用的接口。**

```java
// ❌ 违反 ISP：机器人被迫实现不需要的方法
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() { /* 工作 */ }
    public void eat() { /* 机器人不需要吃 */ }
}

// ✅ 遵循 ISP：拆分接口，按需实现
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Human implements Workable, Eatable {
    public void work() { /* 工作 */ }
    public void eat() { /* 吃饭 */ }
}

class Robot implements Workable {
    public void work() { /* 工作 */ }
}
```

### 依赖倒置原则（DIP）

**高层模块不应依赖低层模块，两者都应依赖抽象。**

```java
// ❌ 违反 DIP：高层直接依赖低层
class LightBulb {
    public void turnOn() { /* 开灯 */ }
}

class Switch {
    private LightBulb bulb;
    public Switch(LightBulb bulb) {
        this.bulb = bulb;
    }
    public void operate() {
        bulb.turnOn();
    }
}

// ✅ 遵循 DIP：依赖抽象接口
interface Switchable {
    void turnOn();
}

class LightBulb implements Switchable {
    public void turnOn() { /* 开灯 */ }
}

class Switch {
    private Switchable device;
    public Switch(Switchable device) {
        this.device = device;
    }
    public void operate() {
        device.turnOn();
    }
}
```

## 2 其他重要设计原则

### 迪米特法则（最少知识原则）

**一个对象应该只与其直接朋友交互。**

```java
// ❌ 违反法则：直接访问陌生对象
class Client {
    public void process(A a) {
        C c = a.getB().getC(); // 访问链过长
        c.doSomething();
    }
}

// ✅ 遵循法则：只与直接朋友交互
class Client {
    public void process(A a) {
        a.process(); // 封装内部交互
    }
}
```

### 高内聚低耦合

- **高内聚**：类内元素紧密相关
- **低耦合**：类间依赖最小化

### 组合优于继承

**优先使用组合，而非继承。**

```java
// 继承：Car继承Vehicle
class Car extends Vehicle { /* ... */ }

// 组合：Car组合Engine，更灵活
class Car {
    private Engine engine;
    public Car(Engine engine) {
        this.engine = engine;
    }
}
```

::: danger 常见误区

- **过度设计**：不是所有代码都要遵循所有原则
- **教条主义**：原则是指导，不是绝对规则
- **忽略上下文**：简单项目无需复杂抽象

> **原则是手段，质量是目标。**
:::
