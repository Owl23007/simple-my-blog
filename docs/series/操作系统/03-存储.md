# 操作系统存储管理

在现代操作系统中，存储管理（内存管理）是核心功能之一，主要负责内存的分配与回收、地址转换、内存扩充（虚拟内存）以及内存保护。

---

## 一、内存管理基础

### 1. 程序的装入与链接

为了让程序运行，必须将其装入内存。

- **编译**：由编译程序将用户源代码编译成若干个目标模块。
- **链接**：由链接程序将目标模块和所需的库函数链接在一起，形成一个完整的装入模块。
  - **静态链接**：运行前链接。
  - **装入时动态链接**：装入内存时链接。
  - **运行时动态链接**：运行时需要该模块才链接（便于共享）。
- **装入**：由装入程序将装入模块装入内存运行。
  - **绝对装入**：编译时产生绝对地址（单道程序）。
  - **可重定位装入（静态重定位）**：装入时一次性完成地址转换。
  - **动态运行时装入（动态重定位）**：运行时进行地址转换（需要重定位寄存器支持）。

### 2. 逻辑地址与物理地址

- **逻辑地址（相对地址）**：CPU 生成的地址，用户程序中使用的地址。
- **物理地址（绝对地址）**：内存单元的真实地址。
- **MMU（内存管理单元）**：硬件机构，负责运行时将逻辑地址映射为物理地址。

---

## 二、连续分配管理方式

指为用户程序分配一个连续的内存空间。

### 1. 单一连续分配

内存分为系统区和用户区，用户区仅驻留一道程序。无外部碎片，有内部碎片。

### 2. 固定分区分配

将用户内存空间划分为若干个固定大小的分区。

- **分区大小相等**：缺乏灵活性。
- **分区大小不等**：适应不同大小的程序。
- **优缺点**：无外部碎片，但有内部碎片（分区内未利用空间）。

### 3. 动态分区分配

不预先划分分区，根据进程大小动态建立。

- **数据结构**：空闲分区表 / 空闲分区链。
- **分配算法**：
  - **首次适应 (First Fit)**: 地址递增，找第一个满足的。最快，保留了高址大空间。
  - **最佳适应 (Best Fit)**: 容量递增，找最小能满足的。产生很多外部碎片。
  - **最坏适应 (Worst Fit)**: 容量递减，找最大的。
  - **邻近适应 (Next Fit)**: 从上次查找结束位置开始。
- **碎片问题**：产生**外部碎片**（分区之间的小不可用空间），可通过**紧凑（Compaction）**技术解决。

---

## 三、非连续分配管理：分页与分段

为了解决连续分配的碎片问题，引入了非连续分配。

### 1. 分页管理（Paging）

#### 基本思想

- 将**进程的虚拟地址空间**和**物理内存**都划分为**固定大小**的块。
  - 虚拟地址空间的块称为**页（Page）**
  - 物理内存的块称为**页框（Page Frame）** 或**页帧**
- 页与页框大小相同（通常为 4KB），便于映射。

#### 地址结构

虚拟地址 = **页号（Page Number）** + **页内偏移（Offset）**

#### 页表

- 每个进程维护一张页表，记录“虚拟页 → 物理页框”的映射。
- **快表 (TLB)**：高速缓存，存放最近访问的页表项，加速地址变换。

#### 优缺点

- **优点**：无外部碎片，内存利用率高。
- **缺点**：页表可能过大（需多级页表）；页面是物理单位，不反映逻辑结构。

### 2. 分段管理（Segmentation）

#### 基本思想

- 按**逻辑意义**将程序划分为若干**段（Segment）**（如代码段、数据段、栈）。
- 每段**长度可变**。

#### 地址结构

虚拟地址 = **段号** + **段内偏移**

#### 优缺点

- **优点**：符合逻辑，便于共享（如共享代码库）和保护。
- **缺点**：产生外部碎片。

### 3. 段页式管理

- 先分段，段内再分页。
- 结合了分页的高效（无外部碎片）和分段的逻辑性（便于共享保护）。

---

## 四、虚拟内存管理

基于**局部性原理**，在程序装入时，只需将当前需要执行的部分页/段装入内存，其余留在外存，执行过程中动态调入/调出。

### 1. 局部性原理

- **时间局部性**：某指令/数据被访问，不久后可能再次被访问（如循环）。
- **空间局部性**：某单元被访问，其附近单元可能被访问（如数组）。

### 2. 请求分页管理

在分页基础上增加了请求调页和页面置换功能。

- **页表项扩展**：增加状态位（是否在内存）、访问字段、修改位、外存地址。
- **缺页中断**：访问的页不在内存时产生，属于内部异常。

### 3. 页面置换算法

当内存不足时，选择换出哪个页面。

| 算法 | 名称 | 描述 | 特点 |
| :--- | :--- | :--- | :--- |
| **OPT** | 最佳置换 | 淘汰以后永不使用或最长时间不使用的页面 | 理论最优，无法实现（需预知未来）。 |
| **FIFO** | 先进先出 | 淘汰最早进入的页面 | 实现简单，但有**Belady异常**（物理块增加，缺页率反而上升）。 |
| **LRU** | 最近最久未使用 | 淘汰最近最长时间未访问的页面 | 性能好，接近OPT。需硬件支持（栈/寄存器），开销大。 |
| **CLOCK** | 时钟置换 (NRU) | 循环扫描，检查访问位 | 性能接近LRU，开销较小。 |

### 4. 抖动 (Thrashing)

- **现象**：刚换出的页马上又要换入，频繁调度，CPU利用率急剧下降。
- **原因**：分配给进程的物理块太少，不能满足工作集需求。
- **工作集**：在某段时间间隔内，进程实际访问的页面集合。

---

> **总结**
>
> - **连续分配**：简单，但有碎片。
> - **分页**：物理视角，解决外部碎片，现代OS主流。
> - **分段**：逻辑视角，便于共享保护。
> - **虚拟内存**：逻辑扩充内存，核心是置换算法 (LRU)。
